import { cast as castArray } from '@johngw/array'
import { IteratorHandler } from '@johngw/iterator'
import { compileFromFile } from 'json-schema-to-typescript'
import { extname, isAbsolute } from 'path'
import ts from 'typescript'
import {
  ImportSpecifierStructure,
  IndentationText,
  NewLineKind,
  OptionalKind,
  Project,
  QuoteKind,
  SyntaxKind,
  Type,
  TypeParameterDeclarationStructure,
  VariableDeclarationKind,
} from 'ts-morph'
import { InstructionSourceType, InstructionTypeTransformers } from './runtypes'
import {
  CanDeclareStatics,
  DeclareAndUse,
  DeclareType,
  Import,
  ImportFromSource,
  Static,
  StaticParameters,
  TypeWriter,
  Write,
} from './TypeWriter'
import TypeWriters from './TypeWriters'
import typeNameFormatter, { TypeNameFormatter } from './typeNameFormatter'
import { find, getRelativeImportPath, isRelative } from './util'
import { groupBy } from 'lodash'
import {
  ConsideredTypeDeclaration,
  doInModule,
  findInModule,
  isCircular,
  isConsideredType,
  isRecursive,
} from './node'
import { getLocalName, SourceCodeFile } from './sourceFile'

type GeneratorOptionsBase =
  | {
      tsConfigFile?: string
    }
  | {
      project?: Project
    }

export type GeneratorOptions = GeneratorOptionsBase & {
  runtypeFormat?: string
  targetFile: string
  typeFormat?: string
  typeWriters: TypeWriters
  transformers: InstructionTypeTransformers
}

export type ImportSpec = Omit<ImportSpecifierStructure, 'kind'> & {
  source: string
}

export default class Generator {
  #circularReferences = new Set<string>()
  #exports = new Set<string>()
  #typeWriters: TypeWriters
  #formatRuntypeName: TypeNameFormatter
  #formatTypeName: TypeNameFormatter
  #project: Project
  #imports: ImportSpec[] = []
  #targetFile: SourceCodeFile
  #transformers: InstructionTypeTransformers

  constructor(options: GeneratorOptions) {
    this.#typeWriters = options.typeWriters

    this.#project =
      'project' in options && options.project
        ? options.project
        : new Project({
            compilerOptions: { strictNullChecks: true },
            manipulationSettings: {
              indentationText: IndentationText.TwoSpaces,
              newLineKind: NewLineKind.LineFeed,
              quoteKind: QuoteKind.Single,
              usePrefixAndSuffixTextForRename: false,
              useTrailingCommas: true,
            },
            skipAddingFilesFromTsConfig: true,
            tsConfigFilePath:
              'tsConfigFile' in options ? options.tsConfigFile : undefined,
          })

    this.#targetFile = this.#project.createSourceFile(
      options.targetFile,
      `// This file is generated by runtyping (https://github.com/johngeorgewright/runtyping).
      // Manual changes might be lost - proceed with caution!`,
      {
        overwrite: true,
      }
    )

    this.#formatRuntypeName = typeNameFormatter(options.runtypeFormat)
    this.#formatTypeName = typeNameFormatter(options.typeFormat)
    this.#transformers = options.transformers
  }

  get project() {
    return this.#project
  }

  async generate(sourceTypes: InstructionSourceType | InstructionSourceType[]) {
    for (const sourceType of castArray(sourceTypes)) {
      switch (extname(sourceType.file)) {
        case '.json':
          await this.#generateRuntypeFromJSON(sourceType)
          break

        case '.d.ts':
        case '.ts':
          this.#generateRuntype(sourceType)
          break

        default:
          throw new Error(`${sourceType.file} is not a typescript or json file`)
      }
    }

    if (this.#imports.length) this.#addImports(this.#imports)

    this.#targetFile.formatText()
    return this.#targetFile
  }

  #addImports(imports: ImportSpec[]) {
    const sourceImportMap = groupBy(imports, 'source')
    for (const [sourceFilePath, imports] of Object.entries(sourceImportMap))
      this.#targetFile.addImportDeclaration({
        namedImports: imports.sort(({ name: nameA }, { name: nameB }) =>
          nameA.localeCompare(nameB)
        ),
        moduleSpecifier: sourceFilePath,
      })
  }

  async #generateRuntypeFromJSON(sourceType: InstructionSourceType) {
    const schema = await compileFromFile(sourceType.file)
    const sourceFile = this.#project.createSourceFile(
      `__temp__${sourceType.file}.ts`,
      schema
    )
    this.#generateRuntype({
      ...sourceType,
      file: sourceFile.getFilePath(),
    })
    this.#project.removeSourceFile(sourceFile)
  }

  #generateRuntype(sourceType: InstructionSourceType) {
    const sourceFile = this.#project.addSourceFileAtPath(
      isAbsolute(sourceType.file) || isRelative(sourceType.file)
        ? sourceType.file
        : require.resolve(sourceType.file)
    )
    for (const typeName of castArray(sourceType.type))
      if (!this.#exports.has(typeName))
        this.#writeRuntype(sourceFile, typeName, sourceType)
  }

  #writeRuntype(
    startingSourceFile: SourceCodeFile,
    sourceType: string,
    instructionSourceType: InstructionSourceType
  ) {
    const typeDeclaration = this.#getTypeDeclaration(
      startingSourceFile,
      sourceType
    )
    const sourceFile = typeDeclaration.getSourceFile()
    const recursive = isRecursive(typeDeclaration)
    const circular = isCircular(typeDeclaration)
    const sourceTypeLocalName = getLocalName(sourceFile, sourceType)
    const runTypeName = this.#formatRuntypeName(sourceTypeLocalName)
    const typeName = this.#formatTypeName(sourceTypeLocalName)
    const exportStaticType =
      instructionSourceType.exportStaticType === undefined
        ? true
        : instructionSourceType.exportStaticType

    let staticImplementation: string | undefined
    let staticTypeParameters:
      | (string | OptionalKind<TypeParameterDeclarationStructure>)[]
      | undefined
    let writer = this.#project.createWriter()
    let runTypeType: string | undefined

    if (circular) {
      this.#circularReferences.add(typeName)
      console.warn(
        `Spotted a circular reference between \`${circular.join(
          '` and `'
        )}\`. This may cause infinite loops at runtime.`
      )
    }

    const canDeclareStatics = (type: Type) =>
      exportStaticType && type.getText() === typeDeclaration.getType().getText()

    const runTypeWriter = (typeWriter: TypeWriter) => {
      IteratorHandler.create(typeWriter)
        .handle(CanDeclareStatics, canDeclareStatics)
        .handle(Write, (value) => {
          writer = writer.write(value)
        })
        .handle(Import, this.#import)
        .handle(ImportFromSource, (importSpec) => {
          this.#importFromSource(sourceFile.getFilePath(), importSpec)
        })
        .handle(Static, ([type, value]) => {
          if (canDeclareStatics(type)) staticImplementation = value
        })
        .handle(StaticParameters, ([type, value]) => {
          if (canDeclareStatics(type)) staticTypeParameters = value
        })
        .handle(DeclareAndUse, (name) => {
          const recursiveValue = recursive && name === typeName
          if (
            recursiveValue ||
            this.#exports.has(name) ||
            this.#hasTypeDeclaration(sourceFile, name)
          ) {
            writer = writer.write(this.#formatRuntypeName(name))
            if (
              !recursiveValue &&
              !this.#exports.has(name) &&
              !this.#circularReferences.has(name)
            )
              this.#writeRuntype(sourceFile, name, instructionSourceType)
            return true
          }
          return undefined
        })
        .handle(DeclareType, (typeName) => {
          runTypeType = typeName
        })
        .run()
    }

    runTypeWriter(
      this.#typeWriters.typeWriter(typeDeclaration.getType(), {
        circular: !!circular,
        recursive,
        transformer: typeDeclaration.getName()
          ? this.#transformers[typeDeclaration.getName()!]
          : undefined,
      })
    )

    if (exportStaticType && !staticImplementation)
      runTypeWriter(
        this.#typeWriters.defaultStaticImplementation(typeDeclaration.getType())
      )

    doInModule(this.#targetFile, runTypeName, (node, name) => {
      node.addVariableStatement({
        isExported: true,
        declarationKind: VariableDeclarationKind.Const,
        declarations: [
          {
            name,
            initializer: writer.toString(),
            type: runTypeType,
          },
        ],
      })

      if (exportStaticType && staticImplementation)
        node.addTypeAlias({
          isExported: true,
          name: typeName.split('.').reduceRight((x) => x),
          type: staticImplementation.replace('${name}', name),
          typeParameters: staticTypeParameters,
        })
    })

    this.#exports.add(sourceType)

    return {
      runTypeName,
      typeName,
    }
  }

  readonly #import = (importSpec: ImportSpec) => {
    const hasImport = this.#imports.find(
      ({ alias, name, source }) =>
        source === importSpec.source &&
        ('alias' in importSpec
          ? alias === importSpec.alias
          : name === importSpec.name)
    )

    if (!hasImport) this.#imports.push(importSpec)
  }

  #importFromSource(
    sourceFilePath: string,
    importSpec: Omit<ImportSpec, 'source'>
  ) {
    this.#import({
      ...importSpec,
      source: getRelativeImportPath(
        this.#targetFile.getFilePath(),
        sourceFilePath
      ),
    })
  }

  /**
   * Will get default export if typeName is not specified
   */
  #getTypeDeclaration(
    sourceFile: SourceCodeFile,
    typeName?: string
  ): ConsideredTypeDeclaration {
    if (!typeName) {
      const declaration = sourceFile
        .getDefaultExportSymbolOrThrow()
        .getValueDeclarationOrThrow()
      if (!isConsideredType(declaration))
        throw new Error(
          `Default export of ${sourceFile.getFilePath()} is an interface, type or enum`
        )
      return declaration
    }

    const importTypeDeclaration = this.#getImportedTypeDeclaration(
      sourceFile,
      typeName
    )

    if (importTypeDeclaration) return importTypeDeclaration

    const declaration = findInModule(
      sourceFile,
      typeName,
      (node, name) =>
        node.getInterface(name) ||
        node.getTypeAlias(name) ||
        node.getEnum(name) ||
        node.getFunction(name) ||
        node.getVariableDeclaration(name)
    )

    if (declaration) return declaration
    else
      throw new Error(
        `Cannot find any interface, type or enum called "${typeName}" in ${sourceFile.getFilePath()}.`
      )
  }

  #getImportedTypeDeclaration(sourceFile: SourceCodeFile, typeName: string) {
    const importInfo = find(
      sourceFile.getImportDeclarations(),
      (importDeclaration) => {
        const defaultImportName = importDeclaration
          .getDefaultImport()
          ?.getText()

        const importSpecifier =
          defaultImportName === typeName
            ? {
                localIdentifier: defaultImportName,
                remoteIdentifier: undefined,
              }
            : find(
                importDeclaration.getImportClause()?.getNamedImports() || [],
                (importSpecifier) => {
                  let [remoteIdentifier, localIdentifier] = importSpecifier
                    .getDescendantsOfKind(SyntaxKind.Identifier)
                    .map((indentifier) => indentifier.getText())
                  localIdentifier = localIdentifier || remoteIdentifier
                  return (
                    (localIdentifier === typeName && {
                      remoteIdentifier,
                      localIdentifier,
                    }) ||
                    false
                  )
                }
              )

        return (
          importSpecifier?.localIdentifier === typeName && {
            path: importDeclaration.getModuleSpecifierValue(),
            remoteIdentifier: importSpecifier.remoteIdentifier,
          }
        )
      }
    )

    if (!importInfo) return

    const importPath = ts.resolveModuleName(
      importInfo.path,
      sourceFile.getFilePath(),
      this.#project.compilerOptions.get(),
      this.#project.getModuleResolutionHost()
    ).resolvedModule?.resolvedFileName

    if (!importPath)
      throw new Error(
        `Cannot find module ${importInfo.path} from ${sourceFile.getFilePath()}`
      )

    const sourceCodeFile = this.#project.addSourceFileAtPath(importPath)
    const typeDeclaration = this.#getTypeDeclaration(
      sourceCodeFile,
      importInfo.remoteIdentifier
    )

    return typeDeclaration
  }

  #hasTypeDeclaration(sourceFile: SourceCodeFile, typeName: string) {
    try {
      return !!this.#getTypeDeclaration(sourceFile, typeName)
    } catch (error: any) {
      return false
    }
  }
}
