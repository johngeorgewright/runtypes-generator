// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`array 1`] = `
"import { TypeOf, array, union, string, number, type } from 'io-ts';

export const A = type({ foo: string, });

export type A = TypeOf<typeof A>;

export const B = array(union([string, number, A,]));

export type B = TypeOf<typeof B>;
"
`;

exports[`boolean 1`] = `
"import { TypeOf, boolean } from 'io-ts';

export const A = boolean;

export type A = TypeOf<typeof A>;
"
`;

exports[`builtin 1`] = `
"import { TypeOf, type, Type, failure, success } from 'io-ts';

export const A = type({
  a: new Type<Uint8Array>(
    'Uint8Array',
    (u): u is Uint8Array => u instanceof Uint8Array,
    (i, c) => i instanceof Uint8Array ? success(i) : failure(i, c, 'not a Uint8Array'),
    (a) => a
  ),
});

export type A = TypeOf<typeof A>;
"
`;

exports[`circular references 1`] = `
"import { TypeOf, union, recursion, Type, type, literal, array } from 'io-ts';
import { Student as _Student, Teacher as _Teacher } from '../fixtures/circular-references';

export const Teacher: Type<_Teacher> = recursion('Teacher', () => type({ type: literal(\\"teacher\\"), students: array(Student), reportsTo: Teacher, }));

export type Teacher = TypeOf<typeof Teacher>;

export const Student: Type<_Student> = recursion('Student', () => type({ type: literal(\\"student\\"), teacher: Teacher, }));

export type Student = TypeOf<typeof Student>;

export const User = union([Student, Teacher,]);

export type User = TypeOf<typeof User>;
"
`;

exports[`dont generate static types 1`] = `
"import { TypeOf, union, type, literal, string, number } from 'io-ts';

export const One = type({ type: literal(\\"one\\"), value: string, });
export const Two = type({ type: literal(\\"two\\"), value: number, });
export const Three = union([One, Two,]);
"
`;

exports[`duplicate references 1`] = `
"import { TypeOf, type, union, null as Null, string } from 'io-ts';

export const FooType = union([Null, string,]);

export type FooType = TypeOf<typeof FooType>;

export const HorseType = type({ a: FooType, b: FooType, });

export type HorseType = TypeOf<typeof HorseType>;
"
`;

exports[`enum 1`] = `
"import { TypeOf, union, literal, string } from 'io-ts';
import { A as _A, B as _B, C as _C, E as _E } from '../fixtures/enum';

export const A = union([literal(_A.A1), literal(_A.B1), literal(_A.C1),]);

export type A = TypeOf<typeof A>;

export const B = union([literal(_B.A2), literal(_B.B2),]);

export type B = TypeOf<typeof B>;

export const D = union([literal(_C.A3), literal(_C.B3),]);

export type D = TypeOf<typeof D>;

export const F = union([string, literal(_E.S),]);

export type F = TypeOf<typeof F>;

export const G = union([literal(_C.A3), literal(_C.B3), literal(_C.C3), literal(_E.S),]);

export type G = TypeOf<typeof G>;
"
`;

exports[`function 1`] = `
"import { TypeOf, Function } from 'io-ts';

export const A = Function;

export type A = TypeOf<typeof A>;

export const B = Function;

export type B = TypeOf<typeof B>;

export const C = Function;

export type C = TypeOf<typeof C>;

export const D = Function;

export type D = TypeOf<typeof D>;

export const E = Function;

export type E = TypeOf<typeof E>;

export const F = Function;

export type F = TypeOf<typeof F>;
"
`;

exports[`function with non-strict nulls 1`] = `
"import { TypeOf, Function } from 'io-ts';

export const C = Function;

export type C = TypeOf<typeof C>;
"
`;

exports[`generics 1`] = `
"import { TypeOf, Type, type, string } from 'io-ts';

export const A = <T extends any,>(T: Type<T>,) => type({ type: T, });

export type A<T> = TypeOf<ReturnType<typeof A<T>>>;

export const B = <T extends string,>(T: Type<T>,) => type({ type: T, });

export type B<T extends string> = TypeOf<ReturnType<typeof B<T>>>;

export const C = <T extends any,>(T: Type<T>,) => type({ type: T, });

export type C<T> = TypeOf<ReturnType<typeof C<T>>>;

export const D = <T extends number,>(T: Type<T>,) => type({ type: T, });

export type D<T extends number> = TypeOf<ReturnType<typeof D<T>>>;

export const E = type({ foo: string, });

export type E = TypeOf<typeof E>;

export const F = <T extends TypeOf<typeof E>,>(T: Type<T>,) => type({ type: T, });

export type F<T extends E> = TypeOf<ReturnType<typeof F<T>>>;
"
`;

exports[`import 1`] = `
"import { TypeOf, type, string } from 'io-ts';

export const A = type({ foo: string, });

export type A = TypeOf<typeof A>;
"
`;

exports[`inheritance 1`] = `
"import { TypeOf, type, string, number, literal } from 'io-ts';

export const C = type({ bar: string, foo: string, });

export type C = TypeOf<typeof C>;

export const D = type({ bar: number, moo: string, foo: number, car: string, });

export type D = TypeOf<typeof D>;

export const E = type({ imported: literal(true), });

export type E = TypeOf<typeof E>;
"
`;

exports[`interface 1`] = `
"import { TypeOf, type, string, number, boolean, literal, Function } from 'io-ts';

export const A = type({ foo: string, bar: number, [\`has spaces\`]: boolean, [\`+1\`]: boolean, [\`-1\`]: boolean, __underscores__: boolean, $dollar: boolean, [\`\\\\\${escaped template vars}\`]: boolean, });

export type A = TypeOf<typeof A>;

export const B = type({ a: A, b: literal(\\"B\\"), });

export type B = TypeOf<typeof B>;

export const C = type({ foo: Function, bar: number, boo: Function, });

export type C = TypeOf<typeof C>;
"
`;

exports[`intersection 1`] = `
"import { TypeOf, intersection, type, string } from 'io-ts';

export const A = type({ foo: string, });

export type A = TypeOf<typeof A>;

export const B = type({ bar: string, });

export type B = TypeOf<typeof B>;

export const C = intersection([A, B,]);

export type C = TypeOf<typeof C>;
"
`;

exports[`json schema 1`] = `
"import { TypeOf, partial, union, tuple, string, record, unknown as Unknown, undefined as Undefined } from 'io-ts';

export const ExampleSchema = partial({ testArray: union([tuple([]), tuple([record(string, Unknown),]), tuple([record(string, Unknown), record(string, Unknown),]), Undefined,]), });

export type ExampleSchema = TypeOf<typeof ExampleSchema>;
"
`;

exports[`json schema 2`] = `
"import { TypeOf, partial, union, tuple, string, record, unknown as Unknown, undefined as Undefined } from 'io-ts';

export const ExampleSchema = partial({ testArray: union([tuple([record(string, Unknown), record(string, Unknown), record(string, Unknown),]), Undefined,]), });

export type ExampleSchema = TypeOf<typeof ExampleSchema>;
"
`;

exports[`json schema 3`] = `
"import { TypeOf, intersection, type, string, partial, union, number, undefined as Undefined, literal } from 'io-ts';

export const ExampleSchema = intersection([type({ firstName: string, lastName: string, }), partial({ age: union([number, Undefined,]), hairColor: union([literal(\\"black\\"), literal(\\"brown\\"), literal(\\"blue\\"), Undefined,]), })]);

export type ExampleSchema = TypeOf<typeof ExampleSchema>;
"
`;

exports[`literal 1`] = `
"import { TypeOf, literal } from 'io-ts';

export const A = literal(\\"foo\\");

export type A = TypeOf<typeof A>;

export const B = literal(2);

export type B = TypeOf<typeof B>;

export const C = literal(true);

export type C = TypeOf<typeof C>;
"
`;

exports[`mapRuntypeName 1`] = `
"import { TypeOf, type, string, array } from 'io-ts';

export const MappedAFoo = type({ foo: string, });

export type MappedABar = TypeOf<typeof MappedAFoo>;

export const MappedBFoo = type({ bar: MappedAFoo, baz: MappedAFoo, nest: type({ baz2: array(MappedAFoo), }), });

export type MappedBBar = TypeOf<typeof MappedBFoo>;
"
`;

exports[`namespace 1`] = `
"import { TypeOf, type, string, number, unknown as Unknown } from 'io-ts';

export namespace A {
  export const B = type({ C: string, });

  export type B = TypeOf<typeof B>;

  export const C = Unknown;

  export type C = TypeOf<typeof C>;

  export const D = type({ E: number, });

  export type D = TypeOf<typeof D>;
}

export namespace B {
  export namespace C {
    export const D = number;

    export type D = TypeOf<typeof D>;
  }
}
"
`;

exports[`non-strict nulls 1`] = `
"import { TypeOf, null as Null, string, intersection, type, partial } from 'io-ts';

export const A = Null;

export type A = TypeOf<typeof A>;

export const B = string;

export type B = TypeOf<typeof B>;

export const C = intersection([type({ a: Null, b: string, }), partial({ c: string, })]);

export type C = TypeOf<typeof C>;
"
`;

exports[`numbers 1`] = `
"import { TypeOf, number } from 'io-ts';

export const A = number;

export type A = TypeOf<typeof A>;
"
`;

exports[`optional property 1`] = `
"import { TypeOf, partial, union, string, undefined as Undefined } from 'io-ts';

export const A = partial({ foo: union([string, Undefined,]), });

export type A = TypeOf<typeof A>;
"
`;

exports[`record 1`] = `
"import { TypeOf, string, record } from 'io-ts';

export const A = record(string, string);

export type A = TypeOf<typeof A>;
"
`;

exports[`recursive 1`] = `
"import { TypeOf, recursion, Type, type, union, string, array } from 'io-ts';
import { A as _A, B as _B } from '../fixtures/recursive';

export const A: Type<_A> = recursion('A', () => type({ recurse: union([string, A,]), }));

export type A = TypeOf<typeof A>;

export const B: Type<_B> = recursion('B', () => type({ recurse: array(B), }));

export type B = TypeOf<typeof B>;
"
`;

exports[`strict nulls 1`] = `
"import { TypeOf, null as Null, union, string, intersection, type, partial, undefined as Undefined } from 'io-ts';

export const A = Null;

export type A = TypeOf<typeof A>;

export const B = union([Null, string,]);

export type B = TypeOf<typeof B>;

export const C = intersection([type({ a: Null, b: union([Null, string,]), }), partial({ c: union([Null, string, Undefined,]), })]);

export type C = TypeOf<typeof C>;
"
`;

exports[`strings 1`] = `
"import { TypeOf, string } from 'io-ts';

export const A = string;

export type A = TypeOf<typeof A>;
"
`;

exports[`tuple 1`] = `
"import { TypeOf, tuple, number, string } from 'io-ts';

export const A = tuple([number, string, number,]);

export type A = TypeOf<typeof A>;

export const B = tuple([A, A,]);

export type B = TypeOf<typeof B>;
"
`;

exports[`union 1`] = `
"import { TypeOf, union, string, number } from 'io-ts';

export const C = union([string, number,]);

export type C = TypeOf<typeof C>;
"
`;
